<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vertical Gantt DAG</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: sans-serif; display: flex; height: 100vh; }
#main { flex: 1; overflow: auto; position: relative; }
#grid { position: relative; min-height: 100%; }
#svg-layer { position: absolute; top: 0; left: 0; pointer-events: none; }
.row { display: flex; min-height: 60px; padding: 5px; gap: 5px; }
.task { width: 120px; height: 50px; border: 1px solid #333; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; background: #fff; font-size: 12px; text-align: center; padding: 2px; }
.task.selected { border: 2px solid #00f; }
.task-arrows { position: absolute; bottom: 2px; right: 2px; font-size: 10px; }
.task-arrows span { cursor: pointer; margin-left: 2px; }
#panel { width: 150px; background: #fff; border-left: 1px solid #ccc; padding: 10px; display: flex; flex-direction: column; gap: 10px; }
#panel button { padding: 8px; cursor: pointer; }
#panel input { padding: 5px; }
.empty-slot { width: 120px; height: 50px; border: 1px dashed #ccc; }
</style>
</head>
<body>
<div id="main">
<div id="grid"></div>
<svg id="svg-layer"></svg>
</div>
<div id="panel">
<button id="btn-add">+ Add Task</button>
<button id="btn-delete">Delete</button>
<hr>
<button id="btn-save">Save As</button>
<input type="file" id="file-load" accept=".json">
<button id="btn-load">Load</button>
</div>
<script>
const pastelColors = ['#ffe6e6','#e6ffe6','#e6e6ff','#ffffe6','#ffe6ff','#e6ffff','#fff0e6','#f0e6ff'];
let tasks = [];
let nextId = 1;
let selectedId = null;
let draggedId = null;

function getTaskById(id) { return tasks.find(t => t.id === id); }

function calcLayers() {
    const layers = {};
    const visited = new Set();
    function getLayer(id) {
        if (layers[id] !== undefined) return layers[id];
        const t = getTaskById(id);
        if (!t) return 0;
        if (t.deps.length === 0) { layers[id] = 0; return 0; }
        let maxDep = 0;
        for (const d of t.deps) {
            if (!visited.has(d)) {
                visited.add(d);
                maxDep = Math.max(maxDep, getLayer(d) + 1);
            }
        }
        layers[id] = maxDep;
        return maxDep;
    }
    tasks.forEach(t => { visited.clear(); getLayer(t.id); });
    return layers;
}

function render() {
    const grid = document.getElementById('grid');
    const svg = document.getElementById('svg-layer');
    grid.innerHTML = '';
    
    const layers = calcLayers();
    const maxLayer = Math.max(0, ...Object.values(layers));
    const rowTasks = [];
    for (let i = 0; i <= maxLayer; i++) rowTasks[i] = [];
    tasks.forEach(t => {
        const l = layers[t.id] || 0;
        rowTasks[l].push(t);
    });
    rowTasks.forEach(rt => rt.sort((a,b) => a.priority - b.priority));
    
    const positions = {};
    
    for (let r = 0; r <= maxLayer; r++) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.background = pastelColors[r % pastelColors.length];
        row.dataset.layer = r;
        
        rowTasks[r].forEach((t, idx) => {
            const div = document.createElement('div');
            div.className = 'task' + (t.id === selectedId ? ' selected' : '');
            div.draggable = true;
            div.dataset.id = t.id;
            div.innerHTML = `<span contenteditable="true" style="outline:none;">${t.name}</span>
                <div class="task-arrows"><span data-dir="left">◀</span><span data-dir="right">▶</span></div>`;
            div.querySelector('span[contenteditable]').onblur = e => { t.name = e.target.textContent || 'Task'; };
            div.onclick = e => { if (e.target.dataset.dir) return; selectedId = t.id; render(); };
            div.ondragstart = e => { draggedId = t.id; };
            div.ondragover = e => e.preventDefault();
            div.ondrop = e => {
                e.preventDefault();
                if (draggedId && draggedId !== t.id) {
                    const dragged = getTaskById(draggedId);
                    if (dragged && !dragged.deps.includes(t.id) && !hasCycle(draggedId, t.id)) {
                        dragged.deps.push(t.id);
                        render();
                    }
                }
                draggedId = null;
            };
            div.querySelector('[data-dir="left"]').onclick = e => { e.stopPropagation(); t.priority = Math.max(0, t.priority - 1); render(); };
            div.querySelector('[data-dir="right"]').onclick = e => { e.stopPropagation(); t.priority++; render(); };
            row.appendChild(div);
        });
        
        const empty = document.createElement('div');
        empty.className = 'empty-slot';
        empty.ondragover = e => e.preventDefault();
        empty.ondrop = e => {
            e.preventDefault();
            if (draggedId) {
                const newT = { id: nextId++, name: 'New Task', deps: [draggedId], priority: rowTasks[r].length };
                tasks.push(newT);
                render();
            }
            draggedId = null;
        };
        row.appendChild(empty);
        grid.appendChild(row);
    }
    
    if (maxLayer < 0 || tasks.length === 0) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.background = pastelColors[0];
        const empty = document.createElement('div');
        empty.className = 'empty-slot';
        empty.ondragover = e => e.preventDefault();
        empty.ondrop = e => { e.preventDefault(); draggedId = null; };
        row.appendChild(empty);
        grid.appendChild(row);
    }
    
    setTimeout(() => {
        const gridRect = grid.getBoundingClientRect();
        svg.setAttribute('width', grid.scrollWidth);
        svg.setAttribute('height', grid.scrollHeight);
        svg.innerHTML = '';
        
        document.querySelectorAll('.task').forEach(el => {
            const rect = el.getBoundingClientRect();
            const id = parseInt(el.dataset.id);
            positions[id] = {
                x: rect.left - gridRect.left + rect.width / 2,
                y: rect.top - gridRect.top + rect.height / 2
            };
        });
        
        tasks.forEach(t => {
            t.deps.forEach(d => {
                const from = positions[t.id];
                const to = positions[d];
                if (from && to) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', from.x);
                    line.setAttribute('y1', from.y);
                    line.setAttribute('x2', to.x);
                    line.setAttribute('y2', to.y);
                    line.setAttribute('stroke', '#333');
                    line.setAttribute('stroke-opacity', '0.6');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('marker-end', 'url(#arrow)');
                    svg.appendChild(line);
                }
            });
        });
        
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `<marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,6 L9,3 z" fill="#333" fill-opacity="0.6"/>
        </marker>`;
        svg.insertBefore(defs, svg.firstChild);
    }, 0);
}

function hasCycle(fromId, newDep) {
    const visited = new Set();
    function dfs(id) {
        if (id === fromId) return true;
        if (visited.has(id)) return false;
        visited.add(id);
        const t = getTaskById(id);
        if (!t) return false;
        for (const d of t.deps) {
            if (dfs(d)) return true;
        }
        return false;
    }
    return dfs(newDep);
}

document.getElementById('btn-add').onclick = () => {
    tasks.push({ id: nextId++, name: 'Task ' + nextId, deps: [], priority: 0 });
    render();
};

document.getElementById('btn-delete').onclick = () => {
    if (selectedId) {
        tasks = tasks.filter(t => t.id !== selectedId);
        tasks.forEach(t => { t.deps = t.deps.filter(d => d !== selectedId); });
        selectedId = null;
        render();
    }
};

document.getElementById('btn-save').onclick = () => {
    const data = JSON.stringify({ tasks, nextId }, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'gantt.json';
    a.click();
};

document.getElementById('btn-load').onclick = () => {
    document.getElementById('file-load').click();
};

document.getElementById('file-load').onchange = e => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                tasks = data.tasks || [];
                nextId = data.nextId || 1;
                selectedId = null;
                render();
            } catch (err) { alert('Invalid file'); }
        };
        reader.readAsText(file);
    }
};

render();
</script>
</body>
</html>