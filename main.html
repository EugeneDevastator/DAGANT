<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vertical Gantt DAG</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: sans-serif; display: flex; height: 100vh; }
#main { flex: 1; overflow: auto; position: relative; }
#grid { position: relative; min-height: 100%; }
#svg-layer { position: absolute; top: 0; left: 0; pointer-events: none; }
.row { display: flex; min-height: 60px; padding: 5px 5px 23px 5px; gap: 5px; }
.task { height: 50px; border: 1px solid #333; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; font-size: 14px; text-align: center; padding: 2px; user-select: none; }
.task.selected { background: #d0e0ff !important; border: 2px solid #00f; }
.task.in-dep-chain { border: 2px solid #ff6600; background: #ffe8d0 !important; }
.task-id { position: absolute; top: 2px; left: 4px; font-size: 10px; color: #666; }
.task-name { outline: none; cursor: text; max-width: 140px; overflow: hidden; }
.task-arrows { position: absolute; bottom: 2px; right: 2px; font-size: 10px; }
.task-arrows span { cursor: pointer; margin-left: 2px; }
#panel { width: 150px; background: #fff; border-left: 1px solid #ccc; padding: 10px; display: flex; flex-direction: column; gap: 10px; }
#panel button { padding: 8px; cursor: pointer; }
#panel input { padding: 5px; }
.empty-slot { height: 50px; border: 1px dashed #ccc; }
</style>
</head>
<body>
<div id="main">
<div id="grid"></div>
<svg id="svg-layer"></svg>
</div>
<div id="panel">
<button id="btn-add">+ Add Task</button>
<button id="btn-delete">Delete</button>
<hr>
<button id="btn-save">Save As</button>
<input type="file" id="file-load" accept=".json">
<button id="btn-load">Load</button>
</div>
<script>
const pastelColors = ['#ffe6e6','#e6ffe6','#e6e6ff','#ffffe6','#ffe6ff','#e6ffff','#fff0e6','#f0e6ff'];
let tasks = [];
let nextId = 1;
let selectedId = null;
let draggedId = null;

function getTaskById(id) { return tasks.find(t => t.id === id); }

function getTaskBgColor(id) {
    return id % 2 === 0 ? '#fff' : '#f5f5f5';
}

function getColumnWidth(colIndex) {
    const baseWidth = 126;
    return baseWidth + (colIndex * 20);
}

function getDependencies(id) {
    const t = getTaskById(id);
    if (!t) return [];
    return t.deps.slice();
}

function getAllDependenciesRecursive(id) {
    const visited = new Set();
    const result = [];
    function dfs(tid) {
        if (visited.has(tid)) return;
        visited.add(tid);
        const t = getTaskById(tid);
        if (!t) return;
        t.deps.forEach(depId => {
            result.push(depId);
            dfs(depId);
        });
    }
    dfs(id);
    return result;
}

function calcLayers() {
    const layers = {};
    const memo = {};
    function getLayer(id) {
        if (memo[id] !== undefined) return memo[id];
        const t = getTaskById(id);
        if (!t) return 0;
        if (t.deps.length === 0) { memo[id] = 0; return 0; }
        let maxDep = 0;
        for (const d of t.deps) {
            maxDep = Math.max(maxDep, getLayer(d) + 1);
        }
        memo[id] = maxDep;
        return maxDep;
    }
    tasks.forEach(t => { layers[t.id] = getLayer(t.id); });
    return layers;
}

function render() {
    const grid = document.getElementById('grid');
    const svg = document.getElementById('svg-layer');
    grid.innerHTML = '';
    
    const layers = calcLayers();
    const maxLayer = Math.max(0, ...Object.values(layers));
    const rowTasks = [];
    for (let i = 0; i <= maxLayer; i++) rowTasks[i] = [];
    tasks.forEach(t => {
        const l = layers[t.id] || 0;
        rowTasks[l].push(t);
    });
    rowTasks.forEach(rt => rt.sort((a,b) => a.priority - b.priority));
    
    const depChain = selectedId ? getAllDependenciesRecursive(selectedId) : [];
    
    for (let r = 0; r <= maxLayer; r++) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.background = pastelColors[r % pastelColors.length];
        row.dataset.layer = r;
        
        rowTasks[r].forEach((t, idx) => {
            const div = document.createElement('div');
            const colWidth = getColumnWidth(idx);
            div.style.width = colWidth + 'px';
            
            let extraClass = '';
            if (t.id === selectedId) {
                extraClass = ' selected';
            } else if (depChain.includes(t.id)) {
                extraClass = ' in-dep-chain';
            }
            
            div.className = 'task' + extraClass;
            if (!extraClass) {
                div.style.background = getTaskBgColor(t.id);
            }
            div.draggable = true;
            div.dataset.id = t.id;
            div.dataset.colIndex = idx;
            div.dataset.layer = r;
            div.innerHTML = `<span class="task-id">#${t.id}</span><span class="task-name" contenteditable="true">${t.name}</span>
                <div class="task-arrows"><span data-dir="left">◀</span><span data-dir="right">▶</span></div>`;
            
            const nameSpan = div.querySelector('.task-name');
            nameSpan.onblur = e => { t.name = e.target.textContent || 'Task'; };
            nameSpan.onkeydown = e => { e.stopPropagation(); };
            nameSpan.onclick = e => { e.stopPropagation(); };
            nameSpan.onmousedown = e => { e.stopPropagation(); };
            
            div.onclick = e => { 
                if (e.target.dataset.dir || e.target.classList.contains('task-name')) return; 
                selectedId = t.id; 
                render(); 
            };
            div.onmousedown = e => {
                if (e.target.classList.contains('task-name')) {
                    div.draggable = false;
                }
            };
            div.onmouseup = e => {
                div.draggable = true;
            };
            div.ondragstart = e => { 
                if (document.activeElement.classList.contains('task-name')) {
                    e.preventDefault();
                    return;
                }
                draggedId = t.id; 
            };
            div.ondragover = e => e.preventDefault();
            div.ondrop = e => {
                e.preventDefault();
                if (draggedId && draggedId !== t.id) {
                    const dragged = getTaskById(draggedId);
                    if (dragged && !dragged.deps.includes(t.id) && !hasCycle(draggedId, t.id)) {
                        dragged.deps.push(t.id);
                        render();
                    }
                }
                draggedId = null;
            };
            div.querySelector('[data-dir="left"]').onclick = e => { e.stopPropagation(); t.priority = Math.max(0, t.priority - 1); render(); };
            div.querySelector('[data-dir="right"]').onclick = e => { e.stopPropagation(); t.priority++; render(); };
            row.appendChild(div);
        });
        
        const empty = document.createElement('div');
        const emptyWidth = getColumnWidth(rowTasks[r].length);
        empty.style.width = emptyWidth + 'px';
        empty.className = 'empty-slot';
        empty.ondragover = e => e.preventDefault();
        empty.ondrop = e => {
            e.preventDefault();
            if (draggedId) {
                const newT = { id: nextId++, name: 'New Task', deps: [draggedId], priority: rowTasks[r].length };
                tasks.push(newT);
                render();
            }
            draggedId = null;
        };
        row.appendChild(empty);
        grid.appendChild(row);
    }
    
    if (maxLayer < 0 || tasks.length === 0) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.background = pastelColors[0];
        const empty = document.createElement('div');
        empty.style.width = getColumnWidth(0) + 'px';
        empty.className = 'empty-slot';
        empty.ondragover = e => e.preventDefault();
        empty.ondrop = e => { e.preventDefault(); draggedId = null; };
        row.appendChild(empty);
        grid.appendChild(row);
    }
    
    setTimeout(() => {
        const gridRect = grid.getBoundingClientRect();
        svg.setAttribute('width', grid.scrollWidth);
        svg.setAttribute('height', grid.scrollHeight);
        svg.innerHTML = '';
        
        const taskRects = {};
        document.querySelectorAll('.task').forEach(el => {
            const rect = el.getBoundingClientRect();
            const id = parseInt(el.dataset.id);
            const layerIndex = parseInt(el.dataset.layer);
            taskRects[id] = {
                left: rect.left - gridRect.left,
                top: rect.top - gridRect.top,
                width: rect.width,
                height: rect.height,
                layer: layerIndex
            };
        });
        
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `<marker id="arrow" markerWidth="6" markerHeight="6" refX="5.4" refY="1.8" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,3.6 L5.4,1.8 z" fill="#333" fill-opacity="0.6"/>
        </marker>`;
        svg.appendChild(defs);
        
        tasks.forEach(t => {
            const fromRect = taskRects[t.id];
            if (!fromRect) return;
            
            t.deps.forEach(d => {
                const toRect = taskRects[d];
                if (!toRect) return;
                
                const fromOffset = Math.min(0.9, fromRect.layer * 0.1);
                const toOffset = Math.min(0.9, toRect.layer * 0.1);
                
                let x1, y1, x2, y2;
                
                if (fromRect.layer > toRect.layer) {
                    x1 = fromRect.left + fromRect.width * fromOffset;
                    y1 = fromRect.top;
                    x2 = toRect.left + toRect.width * toOffset;
                    y2 = toRect.top + toRect.height;
                } else if (fromRect.layer < toRect.layer) {
                    x1 = fromRect.left + fromRect.width * fromOffset;
                    y1 = fromRect.top + fromRect.height;
                    x2 = toRect.left + toRect.width * toOffset;
                    y2 = toRect.top;
                } else {
                    x1 = fromRect.left + fromRect.width * fromOffset;
                    y1 = fromRect.top + fromRect.height / 2;
                    x2 = toRect.left + toRect.width * toOffset;
                    y2 = toRect.top + toRect.height / 2;
                }
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const dx = x2 - x1;
                const dy = y2 - y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const controlDist = Math.min(dist * 0.5, 80);
                
                let pathData;
                if (fromRect.layer > toRect.layer) {
                    const verticalDist = Math.abs(dy);
                    const controlOffset = verticalDist * 0.6;
                    const cx1 = x1;
                    const cy1 = y1 - controlOffset;
                    const cx2 = x2;
                    const cy2 = y2 + controlOffset;
                    pathData = `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
                } else if (fromRect.layer < toRect.layer) {
                    const verticalDist = Math.abs(dy);
                    const controlOffset = verticalDist * 0.6;
                    const cx1 = x1;
                    const cy1 = y1 - controlOffset;
                    const cx2 = x2;
                    const cy2 = y2 - controlOffset;
                    pathData = `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
                } else {
                    const cx1 = x1 + (dx * 0.3);
                    const cy1 = y1;
                    const cx2 = x1 + (dx * 0.7);
                    const cy2 = y2;
                    pathData = `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
                }
                
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', '#333');
                path.setAttribute('stroke-opacity', '0.6');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', 'url(#arrow)');
                svg.appendChild(path);
            });
        });
    }, 0);
}

function hasCycle(fromId, newDep) {
    const visited = new Set();
    function dfs(id) {
        if (id === fromId) return true;
        if (visited.has(id)) return false;
        visited.add(id);
        const t = getTaskById(id);
        if (!t) return false;
        for (const d of t.deps) {
            if (dfs(d)) return true;
        }
        return false;
    }
    return dfs(newDep);
}

document.getElementById('btn-add').onclick = () => {
    tasks.push({ id: nextId++, name: 'Task ' + nextId, deps: [], priority: 0 });
    render();
};

document.getElementById('btn-delete').onclick = () => {
    if (selectedId) {
        tasks = tasks.filter(t => t.id !== selectedId);
        tasks.forEach(t => { t.deps = t.deps.filter(d => d !== selectedId); });
        selectedId = null;
        render();
    }
};

document.getElementById('btn-save').onclick = () => {
    const data = JSON.stringify({ tasks, nextId }, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'gantt.json';
    a.click();
};

document.getElementById('btn-load').onclick = () => {
    document.getElementById('file-load').click();
};

document.getElementById('file-load').onchange = e => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const data = JSON.parse(ev.target.result);
                tasks = data.tasks || [];
                nextId = data.nextId || 1;
                selectedId = null;
                render();
            } catch (err) { alert('Invalid file'); }
        };
        reader.readAsText(file);
    }
};

document.addEventListener('keydown', e => {
    if (document.activeElement.classList.contains('task-name')) return;
    if (!selectedId) return;
    const t = getTaskById(selectedId);
    if (!t) return;
    
    if (e.key === 'ArrowLeft') {
        e.preventDefault();
        t.priority = Math.max(0, t.priority - 1);
        render();
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        t.priority++;
        render();
    }
});

render();
</script>
</body>
</html>